| \rA purely functional approach
| \rto building large applications

| Lambda Days - 27 February 2015


| Noel Markham - \b@noelmarkham
---
```
import scalaz._
import Scalaz._

--
import scala.concurrent._
import scala.concurrent.duration._
import ExecutionContext.Implicits.global

```
---
```
import com.noelmarkham.lambdadays.external.Twitter
```

def getTweets(name: String,
              apiKey: String,
              apiSecret: String): Future[List[Tweet]]

case class UserDetails(screenName: String)
case class Tweet(user: UserDetails, content: String)

--
```
def tweetsFuture =
  Twitter.getTweets("noelmarkham", "key", "secret")
Await.result(tweetsFuture, 1.second)
   .take(3)
   .foreach(t => println(s"${t.content}\n"))
```
---
```
import com.noelmarkham.lambdadays.external.Markov

```

def generateString(text: String,
                   context: Int): Future[String]

--
```
def tweets = Await.result(tweetsFuture, 1.second)
def randomString = Markov.generateString(
          tweets.map(_.content).mkString(" "), 2)
```

--
```
Await.result(randomString, 1.second)
```
---
| \bWiring the two methods together properly

--
```
val apiKey = "APIKey"
val apiSecret = "APISecret"
val context = 2

def randString(username: String): Future[String] = for {
  ts <- Twitter.getTweets(username, apiKey, apiSecret)
  tweetsAsText = tweets.map(_.content).mkString(" ")
  r <- Markov.generateString(tweetsAsText, context)
} yield r
```
--

```
Await.result(randString("noelmarkham"), 1.second)
```
---
| \bExtracting the configuration
--

```
val strLen: String => Int = _.length
val isEven: Int => Boolean = _ % 2 == 0
```
--

```
val isEvenLengthString = strLen andThen isEven
```
--

\b Functions as functors:
--

```
val isEvenLengthString = strLen map isEven
```
---
| \bFunctions as functors
--

```
case class Config(key: String,
                  secret: String,
                  context: Int)
```
--

```
val keyFromConfig: Config => String = _.key
val secretFromConfig: Config => String = _.secret
```
--

```
val keyAndSecret: Config => (String, String) = ???
```
---
| val keyAndSecret: Config => (String, String) = ???

```
val keyAndSecret: Config => (String, String) = c => {
  (keyFromConfig(c), secretFromConfig(c))
}
```
--

```
keyAndSecret(Config("k", "s", 3)) === ("k" -> "s")
```
--

| \rShip it!
---
| val keyAndSecret: Config => (String, String) = ???
--

| \bFunctions as \rmonads
--

```
val keyAndSecret: Config => (String, String) =
  for {
    k <- keyFromConfig
    s <- secretFromConfig
  } yield (k, s)
```
--

```
keyAndSecret(Config("k", "s", 3)) === ("k" -> "s")
```
