| \rA purely functional approach
| \rto building large applications

| Lambda Days - 27 February 2015


| Noel Markham - \b@noelmarkham
---
```
import scalaz._
import Scalaz._

--
import scala.concurrent._
import scala.concurrent.duration._
import ExecutionContext.Implicits.global

```
---
```
import com.noelmarkham.lambdadays.external.Twitter
```

def getTweets(name: String,
              apiKey: String,
              apiSecret: String): Future[List[Tweet]]

case class UserDetails(screenName: String)
case class Tweet(user: UserDetails, content: String)

--
```
def tweetsFuture =
  Twitter.getTweets("noelmarkham", "key", "secret")
Await.result(tweetsFuture, 1.second)
   .take(3)
   .foreach(t => println(s"${t.content}\n"))
```
---
```
import com.noelmarkham.lambdadays.external.Markov

```

def generateString(text: String,
                   context: Int): Future[String]

--
```
def tweets = Await.result(tweetsFuture, 1.second)
def randomString = Markov.generateString(
          tweets.map(_.content).mkString(" "), 2)
```

--
```
Await.result(randomString, 1.second)
```
---
| \bWiring the two methods together

--
```
val apiKey = "APIKey"
val apiSecret = "APISecret"
val context = 2

def randString(username: String): Future[String] = for {
  ts <- Twitter.getTweets(username, apiKey, apiSecret)
  tweetsAsText = tweets.map(_.content).mkString(" ")
  r <- Markov.generateString(tweetsAsText, context)
} yield r
```
--

```
Await.result(randString("noelmarkham"), 1.second)
```
---
| \bExtracting the configuration
--

```
val strLen: String => Int = _.length
val isEven: Int => Boolean = _ % 2 == 0
```
--

```
val isEvenLengthString = strLen andThen isEven
```
--

\b Functions as functors:

```
val isEvenLengthString = strLen map isEven
```
---
| \bFunctions as functors

```
case class Config(key: String,
                  secret: String,
                  context: Int)
```
--

```
val keyFromConfig: Config => String = _.key
val secretFromConfig: Config => String = _.secret
```
--

```
val keyAndSecret: Config => (String, String) = ???
```
---
| \bval keyAndSecret: Config => (String, String) = ???

```
val keyAndSecret: Config => (String, String) = c => {
  (keyFromConfig(c), secretFromConfig(c))
}
```
--

```
keyAndSecret(Config("k", "s", 3)) === ("k" -> "s")
```
--

| \rShip it!
---
| \bval keyAndSecret: Config => (String, String) = ???
--

| \bFunctions as \rmonads
--

```
val keyAndSecret: Config => (String, String) =
  for {
    k <- keyFromConfig
    s <- secretFromConfig
  } yield (k, s)
```
--

```
keyAndSecret(Config("k", "s", 3)) === ("k" -> "s")
```
---
| \bSeparating the configuration

```
def getTweets(username: String):
          Config => Future[List[Twitter.Tweet]] = c => {

  Twitter.getTweets(username, c.key, c.secret)
}

def generateString(text: String):
          Config => Future[String] = c => {

  Markov.generateString(text, c.context)
}
```
---
| \bFlatMap?
--
\rReminder:
def getTweets(username: String):
                   Config => Future[List[Twitter.Tweet]]
def generateString(text: String):
                   Config => Future[String]
--
/
```
def randString(username: String):
                            Config => Future[String]
  for {
    tweets <- getTweets(username)
```
--
    ... ???
--
| \b... lets take a step back
---
| \bReader

```
val keyFromConfig: Config => String = _.key
val secretFromConfig: Config => String = _.secret
```
--

```
val keyFromConfig: Reader[Config, String] =
                                       Reader(_.key)

val secretFromConfig: Reader[Config, String] =
                                       Reader(_.secret)
```
--


```
keyFromConfig.run(Config("key", "secret", 2)) === "key"
```
---
| \bAs before...

```
val keyAndSecret: Reader[Config, (String, String)] =
  for {
    k <- keyFromConfig
    s <- secretFromConfig
  } yield (k, s)
```
--

```
keyAndSecret.run(Config("k", "s", 3)) === ("k" -> "s")
```
---
| \bMonad Transformers

--
| Recap

```
val fo: Future[Option[Int]] = Future(Some(1))
```
--

```
val optionT: OptionT[Future, Int] = OptionT(fo)
```
--

```
val foUpdated = optionT.map(_ + 9) //make this flatMap?
```
--

```
val newFuture: Future[Option[Int]] = foUpdated.run
```
--

```
Await.result(newFuture, 1.second) === Some(10)
```
---
| \bThe ReaderT monad
--

```
val f: String => Future[Int] = s => Future(s.length)
```
--

```
import Kleisli._
val reader: ReaderT[Future, String, Int] = kleisli(f)
```
--

```
val futResult: Future[Int] = reader.run("lambda days")
```
--

```
Await.result(futResult, 1.second) === 11
```
---
| \bBack to our example
\rWe had:
```
--

def getTweets(username: String):
          Config => Future[List[Twitter.Tweet]] = c => {

  Twitter.getTweets(username, c.key, c.secret)
}

def generateString(text: String):
          Config => Future[String] = c => {

  Markov.generateString(text, c.context)
}
```
---
| \bBack to our example
\rChanged to:
```
def getTweets(username: String):
      ReaderT[Future, Config, List[Twitter.Tweet]] = {
  kleisli { c =>
   Twitter.getTweets(username, c.key, c.secret)
  }
}
def generateString(text: String):
      ReaderT[Future, Config, String] = {
  kleisli { c =>
    Markov.generateString(text, c.context)
  }
}
```
---
| \bPlugging the methods together... again!
```
--

def randString(username: String):
                   ReaderT[Future, Config, String] = {
  for {
    tweets <- getTweets(username)
    tweetsAsText = tweets.map(_.content).mkString(" ")
    randomString <- generateString(tweetsAsText)
  } yield randomString
}
```
--

```
def forMe = randString("noelmarkham")
                       .run(Config("apiKey", "secret", 2))
```
--
```
Await.result(forMe, 1.second)
```